from openai import OpenAI
from util.count_token import count_words
from thefuzz import fuzz

client = OpenAI(
    api_key="REPLACEMENT_STRING",
)


def yes_no(answer):
    if answer.lower().startswith("yes"):
        return True
    else:
        return False


def is_relevant(ref, query, score):
    if count_words(query) >= 4 and score >= 86:
        return True

    if count_words(query) >= 10 and score >= 80:
        return True

    if count_words(query) >= 20 and score >= 75:
        return True

    if count_words(query) <= 4 and score < 72:
        return False

    prompt = f"""
    Given a retrieved html content as below:
    {ref}

    Then providing a text generated by imperfect OCR tool; important: it might have typo or mis-recognized characters; as below:
    <input-text>
    {query}
    </input-text>

    Check if the input text is relevant (yes) or not within the given retrieved content.
    Answer briefly (yes or no) without any explanations or formatting.
    """

    answer = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": "Assist user to evaluate search result relevance",
            },
            {"role": "user", "content": prompt},
        ],
        temperature=0.0,
    )

    return yes_no(answer.choices[0].message.content)


def str_gap(origin, mod):
    gap_c = len(mod.strip()) / len(origin.strip())
    gap_w = abs(count_words(mod) - count_words(origin))
    sim = fuzz.partial_ratio(origin.lower(), mod.lower())
    return gap_c, gap_w, sim


def visual_similar(ori, mod):
    prompt=f"""Do you think 2 strings "{ori}" and "{mod}" are visually similar (regardless semantics) ?
    Answer yes or no shortly without explanation or formatting"""
    
    answer = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": "Assist user to compare string visual similarity",
            },
            {"role": "user", "content": prompt},
        ],
        temperature=0.0,
    )
    
    return yes_no(answer.choices[0].message.content)


def is_spelling_correct(text):
    prompt=f"""The <text>{text}</text> is spelling correct?
    Answer yes or no shortly without explanation, formatting or xml tag"""
    
    answer = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": "Assist user to check spelling (primary language is in Vietnamese, sometimes mixed with English, French)",
            },
            {"role": "user", "content": prompt},
        ],
        temperature=0.0,
    )
    return yes_no(answer.choices[0].message.content)


def fix_spelling(text, nearby):
    if nearby.strip():
        prompt=f"""Given a text as below:
        <input-text>{text}</input-text>
        
        Also providing nearby content around the input which is already corrected as below:
        <content> {nearby} </content>
        
        Make correct spelling only if needed (important: just minimal change).
        If the text is actually (random) nonsense sequence, please return original.
        Answer processed text only without explanation, formatting, tag"""
    else:
        prompt=f"""Given a text as below:
        <input-text>{text}</input-text>
        
        Make correct spelling only if needed (important: just minimal change).
        If the text is actually (random) nonsense sequence, please return original.
        Answer processed text only without explanation, formatting, tag"""
        
    
    answer = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": "Assist user to make spelling correction if needed (primary language is in Vietnamese, sometimes mixed with English, French)",
            },
            {"role": "user", "content": prompt},
        ],
        temperature=0.0,
    )
    return answer.choices[0].message.content